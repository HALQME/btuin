# 設計思想

このドキュメントでは、`btuin`がどのような考えに基づいて設計されているかを解説します。APIの表面的な使い方だけでなく、その背景にある「なぜ」を知ることで、ライブラリをより深く、効果的に活用できるようになるでしょう。

---

## すべてはコンポーネント

`btuin`におけるUI構築の最も中心的な思想は、「すべてはコンポーネントである」というものです。画面に表示されるテキスト、レイアウトを構成するコンテナ、そしてアプリケーション全体に至るまで、あらゆるものが「コンポーネント」という統一された概念で扱われます。

`createApp`に渡すアプリケーション定義オブジェクトも、コンポーネントツリーの頂点に立つ、最も外側の特別な**「ルートコンポーネント」**と見なすことができます。

この一貫性により、開発者はアプリケーションのどの部分を構築しているかに関わらず、常に同じ設計原則と思考モデルを適用できます。

---

## コア原則: 状態/ロジックと描画の分離

すべてのコンポーネントは、その複雑さに関わらず、2つの基本的な責務に基づいています。

1.  **状態とロジックの管理**: コンポーネントがどのようなデータを持ち、どのように振る舞うかを定義します。
2.  **描画**: 上記の状態に基づいて、UIがどのように見えるべきかを宣言的に記述します。

この責務の分離は、`btuin`におけるコンポーネント定義の構造に直接反映されています。

```
コンポーネント = 状態/ロジック (init / setup) + 描画 (render / 描画関数)
```

この原則により、各部分の役割が明確になり、コードの見通しが良くなり、テストもしやすくなるというメリットが生まれます。

---

## 2つのコンポーネント定義方法、その意図

`btuin`には、コンポーネントを定義する方法として、意図的に2つの方式が用意されています。

### 1. 低レベルな `init`/`render` 方式

これは、前述の「状態/ロジックと描画の分離」というコア原則を最も直接的に表現した、基本的なコンポーネント形式です。`createApp`に渡すルートコンポーネントの構造と一貫性があり、ライブラリの基盤となるビルディングブロックと言えます。

### 2. 高レベルな `setup` 方式

`init/render`方式はシンプルですが、コンポーネントを部品として再利用する際には、親から子へデータを渡す仕組み（props）などが欲しくなります。

`setup`方式は、この再利用性を高めるために、Vue.jsのようなモダンなフレームワークのアイデアを取り入れて設計された、より高機能なAPIです。これは単なる`init/render`のラッパー（糖衣構文）と考えることができます。

`setup`方式の特筆すべき点は、`setup`関数が**描画関数を返す**という構造です。

```typescript
defineComponent({
  setup() {
    // 状態とロジック
    const count = ref(0);

    // 描画関数（クロージャ）
    return () => Text(`Count is ${count.value}`);
  },
});
```

`setup`と`render`を別のプロパティとして定義するのではなく、`setup`内で描画関数を定義して返す形式になっているのは、**クロージャ**の力を最大限に活用するためです。これにより、`setup`スコープで定義された変数や関数を、描画関数内で`state.`のような接頭辞なしに直接利用でき、より少ない「お決まりのコード」で簡潔にコンポーネントを記述できます。

---

## btuinが目指すもの

これらの設計思想は、`btuin`が目指す以下の目標に集約されます。

- **宣言的なUI**: ターミナルで「カーソルをどう動かすか」といった命令的な操作を考えるのではなく、「UIがどうあるべきか」を宣言的に記述することに集中できます。
- **コンポーネントベースのアーキテクチャ**: UIを独立して再利用可能な部品に分割し、整理・管理することで、大規模なアプリケーションでも破綻しにくい構造を促進します。
- **優れた開発者体験**: `setup`方式やリアクティビティシステムに見られるように、直感的で、より少ないコードで快適に開発できる体験を提供することを目指しています。
